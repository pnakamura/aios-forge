import { AiosAgent, AiosSquad, AiosProject, GeneratedFile, OrchestrationPatternType } from '@/types/aios';
import { ORCHESTRATION_PATTERNS } from '@/data/orchestration-patterns';

interface GenerationInput {
  project: Partial<AiosProject>;
  agents: AiosAgent[];
  squads: AiosSquad[];
  complianceResults?: Record<string, { status: string; notes: string }>;
}

/**
 * Generates a complete, installable AIOS package with all necessary
 * configuration, runtime scaffolding, and documentation files.
 */
export function generateAiosPackage(input: GenerationInput): GeneratedFile[] {
  const { project, agents, squads, complianceResults } = input;
  const files: GeneratedFile[] = [];
  const name = project.name || 'meu-aios';
  const slug = name.toLowerCase().replace(/\s+/g, '-');
  const pattern = project.orchestrationPattern || 'TASK_FIRST';
  const patternInfo = ORCHESTRATION_PATTERNS.find(p => p.id === pattern);

  // ── Core config ──────────────────────────────────────────────
  files.push(generateAiosConfig(name, project, agents, squads, pattern));

  // ── Agent definitions ────────────────────────────────────────
  agents.forEach(agent => {
    files.push(generateAgentMd(agent));
    files.push(generateAgentConfig(agent));
  });

  // ── Squad manifests ──────────────────────────────────────────
  squads.forEach(squad => {
    files.push(generateSquadYaml(squad, agents));
    files.push(generateSquadReadme(squad, agents));
  });

  // ── Runtime scaffolding ──────────────────────────────────────
  files.push(generatePackageJson(slug, name, agents));
  files.push(generateTsConfig());
  files.push(generateMainEntryPoint(name, pattern, agents, squads));
  files.push(generateOrchestratorEngine(pattern, agents, squads));
  files.push(generateAgentRunner());
  files.push(generateLogger());
  files.push(generateTypes(agents, squads));

  // ── Integration & environment ────────────────────────────────
  files.push(generateEnvExample(project));
  files.push(generateEnvValidator());
  files.push(generateDockerfile(slug));
  files.push(generateDockerCompose(slug));
  files.push(generateDockerIgnore());

  // ── Documentation ────────────────────────────────────────────
  files.push(generateReadme(name, project, agents, squads, patternInfo));
  files.push(generateSetupGuide(name, agents));
  files.push(generateArchitectureDoc(name, pattern, agents, squads, patternInfo));

  // ── CI / Scripts ─────────────────────────────────────────────
  files.push(generateGitignore());
  files.push(generateSetupScript(slug));

  // ── Apply compliance results ─────────────────────────────────
  if (complianceResults) {
    files.forEach(f => {
      const result = complianceResults[f.path];
      if (result) {
        f.complianceStatus = result.status as GeneratedFile['complianceStatus'];
        f.complianceNotes = result.notes;
      }
    });
  }

  return files;
}

// ════════════════════════════════════════════════════════════════
// Individual file generators
// ════════════════════════════════════════════════════════════════

function generateAiosConfig(
  name: string,
  project: Partial<AiosProject>,
  agents: AiosAgent[],
  squads: AiosSquad[],
  pattern: OrchestrationPatternType,
): GeneratedFile {
  return {
    path: 'aios.config.yaml',
    type: 'yaml',
    complianceStatus: 'pending',
    content: `# ══════════════════════════════════════════════════
# AIOS Configuration - ${name}
# Generated by AIOS Builder
# ══════════════════════════════════════════════════

name: "${name}"
version: "1.0.0"
domain: "${project.domain || 'software'}"
description: "${(project.description || '').replace(/"/g, '\\"')}"

# Orchestration
orchestration:
  pattern: "${pattern}"
  max_concurrent_tasks: ${pattern === 'PARALLEL_SWARM' ? 10 : pattern === 'SEQUENTIAL_PIPELINE' ? 1 : 5}
  retry_policy:
    max_retries: 3
    backoff_ms: 1000
  timeout_ms: 300000

# Agents
agents:
${agents.map(a => `  - slug: "${a.slug}"
    name: "${a.name}"
    role: "${a.role}"
    model: "${a.llmModel}"
    visibility: "${a.visibility}"
    config: "agents/${a.slug}.yaml"`).join('\n')}

# Squads
squads:
${squads.length > 0 ? squads.map(s => `  - slug: "${s.slug}"
    name: "${s.name}"
    config: "squads/${s.slug}/squad.yaml"
    agents: [${(s.agentIds || []).map(id => `"${id}"`).join(', ')}]`).join('\n') : '  []'}

# Logging
logging:
  level: "info"
  format: "json"
  output: "stdout"

# Runtime
runtime:
  entry: "src/main.ts"
  engine: "node"
  min_version: "20.0.0"
`,
  };
}

function generateAgentMd(agent: AiosAgent): GeneratedFile {
  return {
    path: `agents/${agent.slug}.md`,
    type: 'md',
    complianceStatus: 'pending',
    content: `---
name: "${agent.name}"
slug: "${agent.slug}"
role: "${agent.role}"
model: "${agent.llmModel}"
visibility: "${agent.visibility}"
version: "1.0.0"
custom: ${agent.isCustom}
category: "${agent.category || 'Desenvolvimento'}"
---

# ${agent.name}

> ${agent.role}

## System Prompt

${agent.systemPrompt || '(a definir)'}

## Commands

${(agent.commands || []).length > 0 ? agent.commands.map(c => `- \`${c}\``).join('\n') : '- (nenhum comando configurado)'}

## Tools

${(agent.tools || []).length > 0 ? agent.tools.map(t => `- ${t}`).join('\n') : '- (nenhuma ferramenta configurada)'}

## Skills

${(agent.skills || []).length > 0 ? agent.skills.map(s => `- ${s}`).join('\n') : '- (nenhuma skill configurada)'}
`,
  };
}

function generateAgentConfig(agent: AiosAgent): GeneratedFile {
  return {
    path: `agents/${agent.slug}.yaml`,
    type: 'yaml',
    complianceStatus: 'pending',
    content: `# Agent: ${agent.name}
slug: "${agent.slug}"
name: "${agent.name}"
role: "${agent.role}"
version: "1.0.0"

llm:
  model: "${agent.llmModel}"
  temperature: 0.7
  max_tokens: 4096

visibility: "${agent.visibility}"
is_custom: ${agent.isCustom}

system_prompt: |
  ${(agent.systemPrompt || '').split('\n').join('\n  ')}

commands:
${(agent.commands || []).map(c => `  - "${c}"`).join('\n') || '  []'}

tools:
${(agent.tools || []).map(t => `  - "${t}"`).join('\n') || '  []'}

skills:
${(agent.skills || []).map(s => `  - "${s}"`).join('\n') || '  []'}
`,
  };
}

function generateSquadYaml(squad: AiosSquad, agents: AiosAgent[]): GeneratedFile {
  return {
    path: `squads/${squad.slug}/squad.yaml`,
    type: 'yaml',
    complianceStatus: 'pending',
    content: `# Squad: ${squad.name}
name: "${squad.name}"
slug: "${squad.slug}"
description: "${squad.description || ''}"
version: "1.0.0"

agents:
${(squad.agentIds || []).map(id => {
  const agent = agents.find(a => a.slug === id);
  return `  - slug: "${id}"
    name: "${agent?.name || id}"
    role: "${agent?.role || ''}"`;
}).join('\n') || '  []'}

tasks:
${(squad.tasks || []).map(t => `  - id: "${t.id}"
    name: "${t.name}"
    description: "${t.description || ''}"
    agent: "${t.agentSlug}"
    dependencies: [${t.dependencies.map(d => `"${d}"`).join(', ')}]
    checklist:
${(t.checklist || []).map(c => `      - "${c}"`).join('\n') || '      []'}`).join('\n') || '  []'}

workflows:
${(squad.workflows || []).map(w => `  - id: "${w.id}"
    name: "${w.name}"
    steps:
${(w.steps || []).map(s => `      - id: "${s.id}"
        name: "${s.name}"
        agent: "${s.agentSlug}"${s.condition ? `\n        condition: "${s.condition}"` : ''}`).join('\n') || '      []'}`).join('\n') || '  []'}
`,
  };
}

function generateSquadReadme(squad: AiosSquad, agents: AiosAgent[]): GeneratedFile {
  const squadAgents = (squad.agentIds || []).map(id => agents.find(a => a.slug === id)).filter(Boolean);
  return {
    path: `squads/${squad.slug}/README.md`,
    type: 'md',
    complianceStatus: 'pending',
    content: `# Squad: ${squad.name}

${squad.description || 'Sem descricao.'}

## Agentes

| Agente | Role | Modelo |
|--------|------|--------|
${squadAgents.map(a => `| ${a!.name} | ${a!.role} | \`${a!.llmModel}\` |`).join('\n') || '| (vazio) | - | - |'}

## Tasks

${(squad.tasks || []).length > 0 ? squad.tasks.map((t, i) => `${i + 1}. **${t.name}** - ${t.description || 'Sem descricao'} (agente: \`${t.agentSlug}\`)`).join('\n') : '(nenhuma task definida)'}

## Workflows

${(squad.workflows || []).length > 0 ? squad.workflows.map(w => `### ${w.name}\n${(w.steps || []).map((s, i) => `${i + 1}. ${s.name} (\`${s.agentSlug}\`)`).join('\n')}`).join('\n\n') : '(nenhum workflow definido)'}
`,
  };
}

function generatePackageJson(slug: string, name: string, agents: AiosAgent[]): GeneratedFile {
  const usesOpenAI = agents.some(a => a.llmModel.includes('gpt'));
  const usesClaude = agents.some(a => a.llmModel.includes('claude') || a.llmModel.includes('anthropic'));
  const usesGemini = agents.some(a => a.llmModel.includes('gemini') || a.llmModel.includes('google'));

  const deps: Record<string, string> = {
    'yaml': '^2.4.0',
    'dotenv': '^16.4.0',
    'winston': '^3.14.0',
    'zod': '^3.23.0',
  };

  if (usesOpenAI) deps['openai'] = '^4.60.0';
  if (usesClaude) deps['@anthropic-ai/sdk'] = '^0.30.0';
  if (usesGemini) deps['@google/generative-ai'] = '^0.21.0';
  // Default: always include openai as many providers support OpenAI-compatible API
  if (!usesOpenAI && !usesClaude && !usesGemini) {
    deps['openai'] = '^4.60.0';
    deps['@anthropic-ai/sdk'] = '^0.30.0';
  }

  return {
    path: 'package.json',
    type: 'json',
    complianceStatus: 'pending',
    content: JSON.stringify({
      name: slug,
      version: '1.0.0',
      description: `AIOS System - ${name}`,
      type: 'module',
      main: 'dist/main.js',
      scripts: {
        'build': 'tsc',
        'start': 'node dist/main.js',
        'dev': 'tsx src/main.ts',
        'lint': 'tsc --noEmit',
        'setup': 'bash scripts/setup.sh',
      },
      dependencies: deps,
      devDependencies: {
        'typescript': '^5.5.0',
        'tsx': '^4.19.0',
        '@types/node': '^22.0.0',
      },
      engines: {
        node: '>=20.0.0',
      },
    }, null, 2) + '\n',
  };
}

function generateTsConfig(): GeneratedFile {
  return {
    path: 'tsconfig.json',
    type: 'json',
    complianceStatus: 'pending',
    content: JSON.stringify({
      compilerOptions: {
        target: 'ES2022',
        module: 'ESNext',
        moduleResolution: 'bundler',
        lib: ['ES2022'],
        outDir: './dist',
        rootDir: './src',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        resolveJsonModule: true,
        declaration: true,
        declarationMap: true,
        sourceMap: true,
        baseUrl: '.',
        paths: {
          '@/*': ['./src/*'],
          '@agents/*': ['./agents/*'],
          '@squads/*': ['./squads/*'],
        },
      },
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist'],
    }, null, 2) + '\n',
  };
}

function generateMainEntryPoint(
  name: string,
  pattern: OrchestrationPatternType,
  agents: AiosAgent[],
  squads: AiosSquad[],
): GeneratedFile {
  return {
    path: 'src/main.ts',
    type: 'ts',
    complianceStatus: 'pending',
    content: `/**
 * ${name} - AIOS Main Entry Point
 * Orchestration: ${pattern}
 * Generated by AIOS Builder
 */

import { config } from 'dotenv';
import { validateEnv } from './env.js';
import { createOrchestrator } from './orchestrator.js';
import { createAgentRunner } from './agent-runner.js';
import { logger } from './logger.js';
import type { AiosConfig } from './types.js';

config();

const aiosConfig: AiosConfig = {
  name: "${name}",
  pattern: "${pattern}",
  agents: [
${agents.map(a => `    { slug: "${a.slug}", name: "${a.name}", role: "${a.role}", model: "${a.llmModel}" },`).join('\n')}
  ],
  squads: [
${squads.map(s => `    { slug: "${s.slug}", name: "${s.name}", agentSlugs: [${(s.agentIds || []).map(id => `"${id}"`).join(', ')}] },`).join('\n')}
  ],
};

async function main() {
  logger.info(\`Iniciando \${aiosConfig.name} (padrao: \${aiosConfig.pattern})\`);

  // Validate environment
  const env = validateEnv();
  logger.info('Variaveis de ambiente validadas');

  // Create agent runner (handles LLM calls)
  const runner = createAgentRunner(env);

  // Create orchestrator with the configured pattern
  const orchestrator = createOrchestrator(aiosConfig, runner);

  logger.info(\`\${aiosConfig.agents.length} agente(s) registrado(s)\`);
  logger.info(\`\${aiosConfig.squads.length} squad(s) configurado(s)\`);
  logger.info('Sistema AIOS pronto. Aguardando tarefas...');

  // Example: run a task
  // await orchestrator.run({ task: "Analisar requisitos do projeto", context: {} });

  // Keep alive
  process.on('SIGINT', () => {
    logger.info('Encerrando AIOS...');
    process.exit(0);
  });

  // Interactive mode placeholder
  logger.info('Modo interativo nao implementado. Use a API ou importe o orchestrator.');
}

main().catch((err) => {
  logger.error('Erro fatal:', err);
  process.exit(1);
});

export { aiosConfig };
`,
  };
}

function generateOrchestratorEngine(
  pattern: OrchestrationPatternType,
  agents: AiosAgent[],
  squads: AiosSquad[],
): GeneratedFile {
  return {
    path: 'src/orchestrator.ts',
    type: 'ts',
    complianceStatus: 'pending',
    content: `/**
 * Orchestrator Engine
 * Pattern: ${pattern}
 */

import { logger } from './logger.js';
import type { AiosConfig, AgentRunner, TaskRequest, TaskResult } from './types.js';

export function createOrchestrator(config: AiosConfig, runner: AgentRunner) {
  const agentMap = new Map(config.agents.map(a => [a.slug, a]));
  const squadMap = new Map(config.squads.map(s => [s.slug, s]));

  async function runTask(request: TaskRequest): Promise<TaskResult> {
    logger.info(\`[Orchestrator] Nova tarefa: \${request.task}\`);
    const startTime = Date.now();

    switch (config.pattern) {
      case 'SEQUENTIAL_PIPELINE':
        return runSequential(request);
      case 'PARALLEL_SWARM':
        return runParallel(request);
      case 'HIERARCHICAL':
        return runHierarchical(request);
      case 'WATCHDOG':
        return runWatchdog(request);
      case 'COLLABORATIVE':
        return runCollaborative(request);
      case 'TASK_FIRST':
      default:
        return runTaskFirst(request);
    }
  }

  async function runSequential(request: TaskRequest): Promise<TaskResult> {
    let context = request.context || {};
    const results: string[] = [];

    for (const agent of config.agents) {
      logger.info(\`[Pipeline] Executando agente: \${agent.name}\`);
      const result = await runner.invoke(agent.slug, {
        task: request.task,
        context,
        previousResults: results,
      });
      results.push(result.output);
      context = { ...context, [\`\${agent.slug}_output\`]: result.output };
    }

    return { success: true, output: results[results.length - 1] || '', agentResults: results };
  }

  async function runParallel(request: TaskRequest): Promise<TaskResult> {
    logger.info(\`[Swarm] Executando \${config.agents.length} agentes em paralelo\`);
    const promises = config.agents.map(agent =>
      runner.invoke(agent.slug, { task: request.task, context: request.context || {} })
    );
    const results = await Promise.allSettled(promises);
    const outputs = results.map((r, i) =>
      r.status === 'fulfilled' ? r.value.output : \`Erro em \${config.agents[i].name}: \${r.reason}\`
    );
    return { success: true, output: outputs.join('\\n---\\n'), agentResults: outputs };
  }

  async function runHierarchical(request: TaskRequest): Promise<TaskResult> {
    const master = config.agents.find(a => a.slug === 'aios-master') || config.agents[0];
    if (!master) return { success: false, output: 'Nenhum agente master encontrado', agentResults: [] };

    logger.info(\`[Hierarquico] Master: \${master.name}\`);
    const plan = await runner.invoke(master.slug, {
      task: \`Planeje a execucao da tarefa: \${request.task}. Agentes disponiveis: \${config.agents.map(a => a.name).join(', ')}\`,
      context: request.context || {},
    });

    return { success: true, output: plan.output, agentResults: [plan.output] };
  }

  async function runWatchdog(request: TaskRequest): Promise<TaskResult> {
    const workers = config.agents.filter(a => a.slug !== 'aios-master');
    const supervisor = config.agents.find(a => a.slug === 'aios-master') || config.agents[0];

    const workerResults = await Promise.all(
      workers.map(w => runner.invoke(w.slug, { task: request.task, context: request.context || {} }))
    );

    if (supervisor) {
      const review = await runner.invoke(supervisor.slug, {
        task: \`Revise os seguintes resultados da tarefa "\${request.task}": \${workerResults.map((r, i) => \`\${workers[i].name}: \${r.output}\`).join('\\n')}\`,
        context: request.context || {},
      });
      return { success: true, output: review.output, agentResults: [...workerResults.map(r => r.output), review.output] };
    }

    return { success: true, output: workerResults.map(r => r.output).join('\\n'), agentResults: workerResults.map(r => r.output) };
  }

  async function runCollaborative(request: TaskRequest): Promise<TaskResult> {
    const sharedContext: Record<string, string> = {};
    const rounds = 2;

    for (let round = 0; round < rounds; round++) {
      for (const agent of config.agents) {
        const result = await runner.invoke(agent.slug, {
          task: \`\${request.task}\\n\\nContexto compartilhado:\\n\${JSON.stringify(sharedContext, null, 2)}\`,
          context: request.context || {},
        });
        sharedContext[agent.slug] = result.output;
      }
    }

    return { success: true, output: JSON.stringify(sharedContext, null, 2), agentResults: Object.values(sharedContext) };
  }

  async function runTaskFirst(request: TaskRequest): Promise<TaskResult> {
    const orchestrator = config.agents.find(a => a.slug === 'aios-orchestrator') || config.agents[0];
    if (!orchestrator) return { success: false, output: 'Nenhum orchestrator encontrado', agentResults: [] };

    const plan = await runner.invoke(orchestrator.slug, {
      task: \`Analise a tarefa e atribua ao agente mais adequado: "\${request.task}". Agentes: \${config.agents.map(a => \`\${a.name} (\${a.role})\`).join(', ')}\`,
      context: request.context || {},
    });

    return { success: true, output: plan.output, agentResults: [plan.output] };
  }

  return { run: runTask, agents: agentMap, squads: squadMap };
}
`,
  };
}

function generateAgentRunner(): GeneratedFile {
  return {
    path: 'src/agent-runner.ts',
    type: 'ts',
    complianceStatus: 'pending',
    content: `/**
 * Agent Runner - Handles LLM calls for each agent
 */

import { readFileSync, existsSync } from 'fs';
import { resolve } from 'path';
import { parse } from 'yaml';
import { logger } from './logger.js';
import type { AgentRunner, AgentInvocation, AgentResult, ValidatedEnv } from './types.js';

interface AgentDefinition {
  slug: string;
  name: string;
  system_prompt: string;
  llm: { model: string; temperature: number; max_tokens: number };
}

function loadAgentDefinition(slug: string): AgentDefinition | null {
  const yamlPath = resolve('agents', \`\${slug}.yaml\`);
  if (!existsSync(yamlPath)) return null;
  try {
    const content = readFileSync(yamlPath, 'utf-8');
    return parse(content) as AgentDefinition;
  } catch {
    return null;
  }
}

export function createAgentRunner(env: ValidatedEnv): AgentRunner {
  async function invoke(agentSlug: string, invocation: AgentInvocation): Promise<AgentResult> {
    const definition = loadAgentDefinition(agentSlug);
    const systemPrompt = definition?.system_prompt || \`Voce e o agente \${agentSlug}.\`;
    const model = definition?.llm?.model || 'gpt-4o-mini';

    logger.debug(\`[Agent:\${agentSlug}] Invocando modelo \${model}\`);

    const userMessage = [
      invocation.task,
      invocation.previousResults?.length
        ? \`\\nResultados anteriores:\\n\${invocation.previousResults.join('\\n---\\n')}\`
        : '',
      invocation.context && Object.keys(invocation.context).length > 0
        ? \`\\nContexto:\\n\${JSON.stringify(invocation.context, null, 2)}\`
        : '',
    ].filter(Boolean).join('\\n');

    try {
      // Route to appropriate LLM provider based on model name
      if (model.includes('claude') || model.includes('anthropic')) {
        return await callAnthropic(systemPrompt, userMessage, model, env);
      } else if (model.includes('gemini') || model.includes('google')) {
        return await callOpenAICompatible(systemPrompt, userMessage, model, env);
      } else {
        return await callOpenAI(systemPrompt, userMessage, model, env);
      }
    } catch (error) {
      logger.error(\`[Agent:\${agentSlug}] Erro: \${error}\`);
      return { output: \`Erro ao invocar agente \${agentSlug}: \${error}\`, success: false };
    }
  }

  async function callOpenAI(system: string, user: string, model: string, env: ValidatedEnv): Promise<AgentResult> {
    if (!env.OPENAI_API_KEY) {
      return { output: '[OpenAI] API key nao configurada. Configure OPENAI_API_KEY no .env', success: false };
    }
    const { default: OpenAI } = await import('openai');
    const client = new OpenAI({ apiKey: env.OPENAI_API_KEY });
    const response = await client.chat.completions.create({
      model,
      messages: [{ role: 'system', content: system }, { role: 'user', content: user }],
    });
    return { output: response.choices[0]?.message?.content || '', success: true };
  }

  async function callAnthropic(system: string, user: string, model: string, env: ValidatedEnv): Promise<AgentResult> {
    if (!env.ANTHROPIC_API_KEY) {
      return { output: '[Anthropic] API key nao configurada. Configure ANTHROPIC_API_KEY no .env', success: false };
    }
    const { default: Anthropic } = await import('@anthropic-ai/sdk');
    const client = new Anthropic({ apiKey: env.ANTHROPIC_API_KEY });
    const response = await client.messages.create({
      model: model.replace('anthropic/', ''),
      max_tokens: 4096,
      system,
      messages: [{ role: 'user', content: user }],
    });
    const text = response.content.filter((b: any) => b.type === 'text').map((b: any) => b.text).join('');
    return { output: text, success: true };
  }

  async function callOpenAICompatible(system: string, user: string, model: string, env: ValidatedEnv): Promise<AgentResult> {
    const apiKey = env.OPENAI_API_KEY || env.ANTHROPIC_API_KEY || '';
    if (!apiKey) {
      return { output: '[LLM] Nenhuma API key configurada.', success: false };
    }
    const { default: OpenAI } = await import('openai');
    const client = new OpenAI({ apiKey });
    const response = await client.chat.completions.create({
      model,
      messages: [{ role: 'system', content: system }, { role: 'user', content: user }],
    });
    return { output: response.choices[0]?.message?.content || '', success: true };
  }

  return { invoke };
}
`,
  };
}

function generateLogger(): GeneratedFile {
  return {
    path: 'src/logger.ts',
    type: 'ts',
    complianceStatus: 'pending',
    content: `/**
 * Logger - Structured logging for AIOS
 */

const LEVELS = { debug: 0, info: 1, warn: 2, error: 3 } as const;
type LogLevel = keyof typeof LEVELS;

const currentLevel: LogLevel = (process.env.LOG_LEVEL as LogLevel) || 'info';

function log(level: LogLevel, ...args: unknown[]) {
  if (LEVELS[level] < LEVELS[currentLevel]) return;
  const timestamp = new Date().toISOString();
  const prefix = \`[\${timestamp}] [\${level.toUpperCase()}]\`;
  switch (level) {
    case 'debug': console.debug(prefix, ...args); break;
    case 'info':  console.info(prefix, ...args); break;
    case 'warn':  console.warn(prefix, ...args); break;
    case 'error': console.error(prefix, ...args); break;
  }
}

export const logger = {
  debug: (...args: unknown[]) => log('debug', ...args),
  info:  (...args: unknown[]) => log('info', ...args),
  warn:  (...args: unknown[]) => log('warn', ...args),
  error: (...args: unknown[]) => log('error', ...args),
};
`,
  };
}

function generateTypes(agents: AiosAgent[], squads: AiosSquad[]): GeneratedFile {
  return {
    path: 'src/types.ts',
    type: 'ts',
    complianceStatus: 'pending',
    content: `/**
 * AIOS Type Definitions
 */

export interface AiosConfig {
  name: string;
  pattern: string;
  agents: AgentConfig[];
  squads: SquadConfig[];
}

export interface AgentConfig {
  slug: string;
  name: string;
  role: string;
  model: string;
}

export interface SquadConfig {
  slug: string;
  name: string;
  agentSlugs: string[];
}

export interface TaskRequest {
  task: string;
  context?: Record<string, unknown>;
  targetAgent?: string;
  targetSquad?: string;
}

export interface TaskResult {
  success: boolean;
  output: string;
  agentResults: string[];
}

export interface AgentInvocation {
  task: string;
  context: Record<string, unknown>;
  previousResults?: string[];
}

export interface AgentResult {
  output: string;
  success: boolean;
}

export interface AgentRunner {
  invoke: (agentSlug: string, invocation: AgentInvocation) => Promise<AgentResult>;
}

export interface ValidatedEnv {
  OPENAI_API_KEY?: string;
  ANTHROPIC_API_KEY?: string;
  DATABASE_URL?: string;
  LOG_LEVEL?: string;
  [key: string]: string | undefined;
}
`,
  };
}

function generateEnvExample(project: Partial<AiosProject>): GeneratedFile {
  return {
    path: '.env.example',
    type: 'env',
    complianceStatus: 'pending',
    content: `# ══════════════════════════════════════════════════
# Environment Variables - ${project.name || 'AIOS'}
# Copy this file to .env and fill in the values
# ══════════════════════════════════════════════════

# LLM API Keys (configure at least one)
OPENAI_API_KEY=
ANTHROPIC_API_KEY=

# Database (optional)
DATABASE_URL=

# Logging
LOG_LEVEL=info

# Runtime
NODE_ENV=production
PORT=3000
`,
  };
}

function generateEnvValidator(): GeneratedFile {
  return {
    path: 'src/env.ts',
    type: 'ts',
    complianceStatus: 'pending',
    content: `/**
 * Environment Variable Validator
 */

import type { ValidatedEnv } from './types.js';
import { logger } from './logger.js';

export function validateEnv(): ValidatedEnv {
  const env: ValidatedEnv = {
    OPENAI_API_KEY: process.env.OPENAI_API_KEY,
    ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
    DATABASE_URL: process.env.DATABASE_URL,
    LOG_LEVEL: process.env.LOG_LEVEL || 'info',
  };

  const hasAnyKey = env.OPENAI_API_KEY || env.ANTHROPIC_API_KEY;
  if (!hasAnyKey) {
    logger.warn('Nenhuma API key configurada. Configure OPENAI_API_KEY ou ANTHROPIC_API_KEY no .env');
  }

  return env;
}
`,
  };
}

function generateDockerfile(slug: string): GeneratedFile {
  return {
    path: 'Dockerfile',
    type: 'other',
    complianceStatus: 'pending',
    content: `FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./
COPY --from=builder /app/agents ./agents
COPY --from=builder /app/squads ./squads
COPY --from=builder /app/aios.config.yaml ./
ENV NODE_ENV=production
CMD ["node", "dist/main.js"]
`,
  };
}

function generateDockerCompose(slug: string): GeneratedFile {
  return {
    path: 'docker-compose.yaml',
    type: 'yaml',
    complianceStatus: 'pending',
    content: `version: "3.8"

services:
  aios:
    build: .
    container_name: ${slug}
    restart: unless-stopped
    env_file: .env
    ports:
      - "\${PORT:-3000}:3000"
    volumes:
      - ./agents:/app/agents:ro
      - ./squads:/app/squads:ro
      - ./aios.config.yaml:/app/aios.config.yaml:ro
`,
  };
}

function generateDockerIgnore(): GeneratedFile {
  return {
    path: '.dockerignore',
    type: 'other',
    complianceStatus: 'pending',
    content: `node_modules
dist
.env
.git
*.md
!README.md
`,
  };
}

function generateReadme(
  name: string,
  project: Partial<AiosProject>,
  agents: AiosAgent[],
  squads: AiosSquad[],
  patternInfo?: any,
): GeneratedFile {
  return {
    path: 'README.md',
    type: 'md',
    complianceStatus: 'pending',
    content: `# ${name}

${project.description || 'Sistema AIOS de orquestracao de agentes IA.'}

## Visao Geral

| Propriedade | Valor |
|-------------|-------|
| Dominio | ${project.domain || 'software'} |
| Orquestracao | ${patternInfo?.name || project.orchestrationPattern || 'Task-First'} |
| Agentes | ${agents.length} |
| Squads | ${squads.length} |

## Quick Start

\`\`\`bash
# 1. Instale as dependencias
npm install

# 2. Configure as variaveis de ambiente
cp .env.example .env
# Edite .env com suas API keys

# 3. Execute em modo desenvolvimento
npm run dev

# 4. Ou compile e execute
npm run build
npm start
\`\`\`

## Docker

\`\`\`bash
# Build e execute
docker compose up --build

# Ou apenas build
docker build -t ${name.toLowerCase().replace(/\s+/g, '-')} .
\`\`\`

## Agentes

${agents.map(a => `- **${a.name}** - ${a.role} (\`${a.llmModel}\`)`).join('\n') || '(nenhum agente configurado)'}

## Squads

${squads.map(s => `- **${s.name}** - ${s.description || s.slug} (${(s.agentIds || []).length} agentes)`).join('\n') || '(nenhum squad configurado)'}

## Estrutura de Arquivos

\`\`\`
.
├── aios.config.yaml      # Configuracao principal
├── package.json           # Dependencias
├── tsconfig.json          # Configuracao TypeScript
├── Dockerfile             # Container Docker
├── docker-compose.yaml    # Orquestracao Docker
├── src/
│   ├── main.ts            # Entry point
│   ├── orchestrator.ts    # Motor de orquestracao
│   ├── agent-runner.ts    # Executor de agentes (LLM)
│   ├── logger.ts          # Logging estruturado
│   ├── env.ts             # Validacao de ambiente
│   └── types.ts           # Definicoes de tipos
├── agents/                # Definicoes de agentes
${agents.map(a => `│   ├── ${a.slug}.md\n│   └── ${a.slug}.yaml`).join('\n')}
└── squads/                # Definicoes de squads
${squads.map(s => `    └── ${s.slug}/\n        ├── squad.yaml\n        └── README.md`).join('\n')}
\`\`\`

## Licenca

Projeto privado. Todos os direitos reservados.
`,
  };
}

function generateSetupGuide(name: string, agents: AiosAgent[]): GeneratedFile {
  return {
    path: 'docs/setup.md',
    type: 'md',
    complianceStatus: 'pending',
    content: `# Guia de Instalacao - ${name}

## Pre-requisitos

- Node.js >= 20.0.0
- npm ou yarn
- Uma API key de LLM (OpenAI, Anthropic, ou Google)

## Passo a Passo

### 1. Instalar Dependencias

\`\`\`bash
npm install
\`\`\`

### 2. Configurar Ambiente

\`\`\`bash
cp .env.example .env
\`\`\`

Edite o arquivo \`.env\` e configure pelo menos uma API key:

- \`OPENAI_API_KEY\` - Para modelos GPT
- \`ANTHROPIC_API_KEY\` - Para modelos Claude

### 3. Verificar Configuracao

Revise o arquivo \`aios.config.yaml\` para ajustar:
- Padrao de orquestracao
- Agentes ativos
- Configuracoes de runtime

### 4. Executar

\`\`\`bash
# Modo desenvolvimento (com hot-reload)
npm run dev

# Modo producao
npm run build && npm start
\`\`\`

### 5. Docker (Opcional)

\`\`\`bash
docker compose up --build
\`\`\`

## Personalizacao

### Modificar Agentes

Edite os arquivos em \`agents/\` para customizar:
- System prompts
- Modelos LLM
- Comandos e ferramentas

### Modificar Squads

Edite os arquivos em \`squads/\` para ajustar:
- Composicao de agentes
- Tasks e workflows
- Dependencias entre tarefas
`,
  };
}

function generateArchitectureDoc(
  name: string,
  pattern: OrchestrationPatternType,
  agents: AiosAgent[],
  squads: AiosSquad[],
  patternInfo?: any,
): GeneratedFile {
  return {
    path: 'docs/architecture.md',
    type: 'md',
    complianceStatus: 'pending',
    content: `# Arquitetura - ${name}

## Padrao de Orquestracao: ${patternInfo?.name || pattern}

${patternInfo?.description || ''}

## Diagrama de Fluxo

\`\`\`
${generateAsciiDiagram(pattern, agents, squads)}
\`\`\`

## Agentes

${agents.map(a => `### ${a.name}
- **Role:** ${a.role}
- **Modelo:** \`${a.llmModel}\`
- **Visibilidade:** ${a.visibility}
- **Comandos:** ${(a.commands || []).map(c => `\`${c}\``).join(', ') || 'nenhum'}
`).join('\n')}

## Squads

${squads.map(s => `### ${s.name}
- **Descricao:** ${s.description || 'N/A'}
- **Agentes:** ${(s.agentIds || []).join(', ') || 'vazio'}
- **Tasks:** ${s.tasks.length}
- **Workflows:** ${s.workflows.length}
`).join('\n') || '(nenhum squad)'}
`,
  };
}

function generateAsciiDiagram(
  pattern: OrchestrationPatternType,
  agents: AiosAgent[],
  squads: AiosSquad[],
): string {
  const names = agents.map(a => a.name.substring(0, 12));
  if (names.length === 0) return '  (sem agentes)';

  switch (pattern) {
    case 'SEQUENTIAL_PIPELINE':
      return `  ${names.join(' --> ')}`;
    case 'PARALLEL_SWARM':
      return `        ┌─ ${names[0] || '?'}\n  Start ─┼─ ${names[1] || '?'}\n        └─ ${names.slice(2).join('\n        └─ ') || '...'}`;
    case 'HIERARCHICAL':
      return `       [Master]\n     /    |    \\\n  ${names.slice(0, 3).join('  ')}`;
    default:
      return `  [Orchestrator] --> [${names.join(', ')}]`;
  }
}

function generateGitignore(): GeneratedFile {
  return {
    path: '.gitignore',
    type: 'other',
    complianceStatus: 'pending',
    content: `node_modules/
dist/
.env
*.log
.DS_Store
`,
  };
}

function generateSetupScript(slug: string): GeneratedFile {
  return {
    path: 'scripts/setup.sh',
    type: 'other',
    complianceStatus: 'pending',
    content: `#!/bin/bash
set -e

echo "================================================"
echo "  Setup: ${slug}"
echo "================================================"
echo ""

# Check Node.js version
NODE_VERSION=$(node -v 2>/dev/null | cut -d'v' -f2 | cut -d'.' -f1)
if [ -z "$NODE_VERSION" ] || [ "$NODE_VERSION" -lt 20 ]; then
  echo "ERRO: Node.js >= 20 necessario. Versao atual: $(node -v 2>/dev/null || echo 'nao instalado')"
  exit 1
fi
echo "Node.js: $(node -v)"

# Install dependencies
echo ""
echo "Instalando dependencias..."
npm install

# Setup .env
if [ ! -f .env ]; then
  echo ""
  echo "Criando .env a partir de .env.example..."
  cp .env.example .env
  echo "IMPORTANTE: Edite .env e configure suas API keys."
fi

# Build
echo ""
echo "Compilando TypeScript..."
npm run build

echo ""
echo "================================================"
echo "  Setup concluido!"
echo "  Execute: npm run dev"
echo "================================================"
`,
  };
}
